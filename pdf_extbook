#!/usr/bin/env python3
# Copyright 2024 Raffaele Mancuso
# SPDX-License-Identifier: MIT

# Extract PDF pages on bookmark boundaries

import subprocess
import tempfile
import os
import readline
import argparse
import re
from pathlib import Path
from dataclasses import dataclass


@dataclass
class Bookmark:
    title: str
    level: int
    start_page: int
    end_page: int


# Ask for user input with a pre-filled default value
def rlinput(prompt, prefill=""):
    readline.set_startup_hook(
        lambda: readline.insert_text(prefill)
    )
    try:
        return input(
            prompt
        )  # or raw_input in Python 2
    finally:
        readline.set_startup_hook()


# Main

# Parse command line arguments
parser = argparse.ArgumentParser(
    prog="pdf_extbook",
    description="Extract PDF pages on bookmark boundaries",
)
level_group = parser.add_mutually_exclusive_group()
level_group.add_argument(
    "-m",
    "--max-level",
    help="Max bookmark level the user can choose from (levels start from 1).",
    default=None,
    type=int,
)
level_group.add_argument(
    "-e",
    "--exact-level",
    help="Exact bookmark level the user can choose from (levels start from 1).",
    default=None,
    type=int,
)
parser.add_argument(
    "-E",
    "--extraction-engine",
    help="Engine used to extract pages from PDF. Can be pdftk (default), qpdf, pdfjam.",
    default="pdftk",
    type=str,
    choices={"pdftk", "qpdf", "pdfjam"},
)
parser.add_argument(
    "file",
    help="The PDF file from which to extract bookmarks.",
)
args = parser.parse_args()

# Use pdftk to extract bookmarks from PDF
print("Extracting bookmarks...")
cmd = ["pdftk", args.file, "dump_data_utf8"]
bl = subprocess.run(
    cmd, text=True, capture_output=True
).stdout.splitlines()
bl = [x for x in bl if x.startswith("Bookmark")]
bl2 = "\n".join(bl)

# Process bookmarks
tag_title = "BookmarkTitle: "
tag_level = "BookmarkLevel: "
tag_page = "BookmarkPageNumber: "

pat = tag_title + "(.+?)\n" + tag_level + "(.+?)\n" + tag_page + "(.+?)$"

titles = list()
levels = list()
pages = list()
for m in re.finditer(pat, bl2, re.MULTILINE):
    title = m.group(1)
    level = int(m.group(2))
    page = int(m.group(3))
    titles.append(title)
    levels.append(level)
    pages.append(page)

assert len(titles) == len(levels)
assert len(titles) == len(pages)

with tempfile.NamedTemporaryFile("w") as input_file:
    with tempfile.NamedTemporaryFile("r") as output_file:
        it = enumerate(zip(titles, levels, pages))
        # Write bookmarks in a file that will be read by fzf
        for i, (title, level, start_page) in it:
            if (
                args.max_level
                and level > args.max_level
            ):
                continue
            if (
                args.exact_level
                and level != args.exact_level
            ):
                continue
            try:
                pos = (
                    levels[i + 1:].index(level)
                    + i
                    + 1
                )
                end_page = pages[pos] - 1
            except ValueError:
                end_page = None
            input_file.write(
                title
                + " ["
                + str(start_page)
                + "-"
                + str(end_page)
                + "]\n",
            )
        input_file.flush()

        # Ask user which bookmark to extract with fzf
        os.system(
            "fzf --reverse "
            f'< "{input_file.name}" '
            f'> "{output_file.name}"'
        )
        # Read user choice from file
        choice = output_file.read().strip()

# Get page boundaries
pages = choice.split(" ")[-1][1:-1].split("-")
start_page, end_page = pages

# Ask user for output file
# pos = len(choice) - choice[::-1].index("[")
# proposal = choice[:pos-2]
proposal = (
    re.search(r"\[.*?](.*)\[.*?\]", choice)
    .group(1)
    .strip()
)
proposal = (
    proposal[:50]
    .replace(" ", "_")
    .replace("[", "")
    .replace("]", "")
    .replace(".", "_")
    .replace(":", "")
    .replace("-", "_")
)
proposal += ".pdf"
outfp = rlinput("Output file: ", proposal)
outfp = Path(outfp)
outfp = outfp.resolve()
print(f"Saving to: `{outfp}`")

# Actually extract the pages

if args.extraction_engine == "pdftk":
    print("Using pdftk to extract pages")
    # You can reference page numbers in reverse order by prefixing them with the letter r.
    # For example, page r1 is the last page of the document,
    # r2 is the next-to-last page of the document,
    # and rend is the first page of the document.
    # You can use this prefix in ranges, too, for example r3-r1 is the last three pages of a PDF.
    if end_page is None:
        end_page = "r1"
    cmd = [
        "pdftk",
        args.file,
        "cat",
        str(start_page) + "-" + str(end_page),
        "output",
        str(outfp),
    ]
    res = subprocess.run(cmd)

elif args.extraction_engine == "qpdf":
    print("Using qpdf to extract pages")
    # From qpdf documentation:
    # A number preceded by r counts from the end, so r1 is the last page, r2 is the second-to-last page, etc.
    if end_page is None:
        end_page = "r1"
    cmd = [
        "qpdf",
        "--empty",
        "--pages",
        args.file,
        str(start_page) + "-" + str(end_page),
        "--",
        outfp,
    ]
    res = subprocess.run(cmd)

elif args.extraction_engine == "pdfjam":
    print("Using pdfjam to extract pages")
    # In pdfjam, the last page corresponds to the empty string
    if end_page is None:
        end_page = ""
    cmd = [
        "pdfjam",
        args.file,
        str(start_page) + "-" + str(end_page),
        "-o",
        outfp,
    ]
    res = subprocess.run(cmd)

else:
    raise Exception("Unsupported extraction engine")

assert (res.returncode == 0)

# DEBUG
# print(pos)
# print(level)
# print(start_page)
# print(end_page)
# print(cmd)
